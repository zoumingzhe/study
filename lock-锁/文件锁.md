文件锁
======

# linux中的文件锁
## flock
```C
#include <sys/file.h>
int flock(int fd, int operation);
```

对fd指定的打开文件加锁或解锁。

operation参数是以下之一：
 - LOCK_SH ：共享锁
 - LOCK_EX ：排他锁
 - LOCK_UN ：解锁

如果另一个进程持有不兼容的锁，则加锁调用会阻塞，直到不兼容的锁被全部释放。

若要发出非阻塞的加锁请求，可以使用LOCK_SH|LOCK_NB或LOCK_EX|LOCK_NB参数。


## lockf
```C
#include <unistd.h>
int lockf(int fd, int cmd, off_t len);
```

## flock与lockf的共同点
1.  加锁可递归：即如果一个进程对一个文件已加锁，继续加锁则新锁将替换老锁，而不会产生死锁。

## flock与lockf的不同点

1.  flock只能对整个文件加锁，而不能对文件的某一区域加锁。
    lockf可以对文件的某一区域加锁。

2.  flock创建的锁是和文件打开表项（struct file）相关联的，而不是fd。

    这就意味着复制文件fd（通过fork或者dup）后，那么通过这两个fd都可以操作同一把锁（例如：通过一个fd加锁，通过另一个fd可以释放锁），也就是说子进程继承父进程的锁。

    关闭其中一个fd，锁并不会释放（因为file结构并没有释放），只有关闭所有复制出的fd，锁才会释放。

    而父进程lockf所创建的锁不能被fork产生的子进程所继承。

    任何时候关闭一个文件描述符，则这一文件描述符所指文件的其他未关闭文件描述符上的任何（该进程）通过lockf所创建的锁都将被释放。

例如如下代码：
```
fd1 = open(path, …);
lockf(fd1, F_LOCK, 0);
fd2 = dup(fd1);
close(fd2);
```

则在close(fd2)后，fd1上的加锁会被释放。

如果将dup替换为open同一文件（即打开同一文件的另一文件描述符），其效果一样。

3.  lockf加读锁（共享锁）文件必须是读打开的，加写锁（排他锁）文件必须是写打开。
    flock无此限制。

## flock与lockf的关系
flock的加锁和lockf的加锁互不影响。即通过flock加写锁（排他锁）后，仍然可以通过lockf加写锁（排他锁）。

# 文件锁的使用错误
## 对'w'、'w+'、'wb'、'wb+'等模式所打开文件的加锁
例如如下代码：
```python
import os
import fcntl

def save(self, filename):
    if filename is not None:
        fd = open(filename, 'wb')
        fcntl.flock(fd, fcntl.LOCK_EX)
        try:
            fd.write(...)
        finally:
            fd.close()

def load(self, filename):
    if filename is not None and os.path.exists(filename):
        fd = open(filename, 'rb')
        fcntl.flock(fd, fcntl.LOCK_SH)
        try:
            fd.read()
        finally:
            fd.close()
```

这段代码通过文件锁解决读、写并发问题，但是长期运行该代码，偶尔会出现读不到文件内容（读到的内容为空）的情况。

这是因为写数据以'w'、'w+'、'wb'、'wb+'等模式打开文件隐含了truncate操作，该操作在文件锁之外。若此时读数据加锁成功，则读到的内容为空。

# 参考
 * [flock(2) - Linux man page](https://linux.die.net/man/2/flock)
 * [lockf(3) - Linux man page](https://linux.die.net/man/3/lockf)
 * [linux中fcntl()、lockf、flock的区别](http://blog.chinaunix.net/uid-28541347-id-5678998.html)
